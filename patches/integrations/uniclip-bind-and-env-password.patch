--- a/uniclip.go	2026-02-18 14:43:53
+++ b/uniclip.go	2026-02-18 14:47:56
@@ -30,16 +30,20 @@
 	helpMsg                           = `Uniclip - Universal Clipboard
 With Uniclip, you can copy from one device and paste on another.
 
-Usage: uniclip [--secure/-s] [--debug/-d] [ <address> | --help/-h ]
+Usage: uniclip [--secure/-s] [--debug/-d] [--bind/-b <addr>] [ <address> | --help/-h ]
 Examples:
    uniclip                                   # start a new clipboard
    uniclip -p 6666                           # start a new clipboard on a set port number
+   uniclip --bind 127.0.0.1 -p 6666         # start on localhost only
    uniclip 192.168.86.24:53701               # join the clipboard at 192.168.86.24:53701
    uniclip -d                                # start a new clipboard with debug output
    uniclip -d --secure 192.168.86.24:53701   # join the clipboard with debug output and enable encryption
 Running just ` + "`uniclip`" + ` will start a new clipboard.
 It will also provide an address with which you can connect to the same clipboard with another device.
-Refer to https://github.com/quackduck/uniclip for more information`
+Refer to https://github.com/quackduck/uniclip for more information
+
+Environment variables:
+  UNICLIP_PASSWORD  Password for --secure (avoids interactive prompt)`
 	listOfClients  = make([]*bufio.Writer, 0)
 	localClipboard string
 	printDebugInfo = false
@@ -48,11 +52,12 @@
 	secure         = false
 	password       []byte
 	port           = 0
+	bindAddr       = ""
 )
 
 // TODO: Add a way to reconnect (if computer goes to sleep)
 func main() {
-	if len(os.Args) > 4 {
+	if len(os.Args) > 8 {
 		handleError(errors.New("too many arguments"))
 		fmt.Println(helpMsg)
 		return
@@ -71,9 +76,14 @@
 	if hasOption, i := argsHaveOption("secure", "s"); hasOption {
 		secure = true
 		os.Args = removeElemFromSlice(os.Args, i) // delete the secure option and run again
-		fmt.Print("Password for --secure: ")
-		password, _ = terminal.ReadPassword(int(syscall.Stdin))
-		fmt.Println()
+		if envPass := os.Getenv("UNICLIP_PASSWORD"); envPass != "" {
+			password = []byte(envPass)
+			debug("using password from UNICLIP_PASSWORD env var")
+		} else {
+			fmt.Print("Password for --secure: ")
+			password, _ = terminal.ReadPassword(int(syscall.Stdin))
+			fmt.Println()
+		}
 		main()
 		return
 	}
@@ -97,6 +107,21 @@
 		main()
 		return
 	}
+	if hasOption, i := argsHaveOption("bind", "b"); hasOption {
+		os.Args = removeElemFromSlice(os.Args, i) // delete the bind option
+		if bindAddr != "" {
+			fmt.Fprintln(os.Stderr, "Only one bind address allowed")
+			os.Exit(1)
+		}
+		if len(os.Args) < i+1 {
+			fmt.Fprintln(os.Stderr, "Missing bind address")
+			os.Exit(1)
+		}
+		bindAddr = os.Args[i]
+		os.Args = removeElemFromSlice(os.Args, i) // delete the bind argument and run again
+		main()
+		return
+	}
 	if hasOption, _ := argsHaveOption("version", "v"); hasOption {
 		fmt.Println(version)
 		return
@@ -110,11 +135,11 @@
 
 func makeServer() {
 	fmt.Println("Starting a new clipboard")
-	listenPortString := ":"
+	listenPortString := bindAddr + ":"
 	if port > 0 {
-		listenPortString = ":" + strconv.Itoa(port)
+		listenPortString = bindAddr + ":" + strconv.Itoa(port)
 	}
-	l, err := net.Listen("tcp4", listenPortString) //nolint // complains about binding to all interfaces
+	l, err := net.Listen("tcp4", listenPortString)
 	if err != nil {
 		handleError(err)
 		return
